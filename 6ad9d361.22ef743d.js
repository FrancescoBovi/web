(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{61:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return o})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return p}));var a=n(2),i=(n(0),n(75)),s=n(77);const r={title:"Todo App"},o={unversionedId:"tutorials/todo-app",id:"tutorials/todo-app",isDocsHomePage:!1,title:"Todo App",description:"Let's build a simple Todo App together in Wasp!",source:"@site/docs/tutorials/todo-app.md",slug:"/tutorials/todo-app",permalink:"/docs/tutorials/todo-app",editUrl:"https://github.com/wasp-lang/web/edit/master/docs/tutorials/todo-app.md",version:"current",sidebar:"docs",previous:{title:"Getting Started",permalink:"/docs/tutorials/getting-started"},next:{title:"Overview",permalink:"/docs/language/overview"}},c=[{value:"New project",id:"new-project",children:[]},{value:"Task Entity",id:"task-entity",children:[]},{value:"Listing tasks",id:"listing-tasks",children:[]},{value:"Creating new tasks",id:"creating-new-tasks",children:[{value:"Wasp action",id:"wasp-action",children:[]},{value:"React form",id:"react-form",children:[]},{value:"Automatic invalidation/updating of queries",id:"automatic-invalidationupdating-of-queries",children:[]}]},{value:"Updating tasks",id:"updating-tasks",children:[]},{value:"Clocks",id:"clocks",children:[]},{value:"User + authentication",id:"user--authentication",children:[]},{value:"The End",id:"the-end",children:[]}],l={rightToc:c};function p({components:e,...t}){return Object(i.b)("wrapper",Object(a.a)({},l,t,{components:e,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Let's build a simple Todo App together in Wasp!"),Object(i.b)("img",{alt:"How Todo App will work once it is done",src:Object(s.a)("img/todo-app-tutorial-intro.gif"),style:{border:"1px solid black"}}),Object(i.b)("p",null,"If you haven't yet set up Wasp, check ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/tutorials/getting-started"}),"Getting Started")," first for installation instructions."),Object(i.b)("h2",{id:"new-project"},"New project"),Object(i.b)("p",null,"First, let's create a new Wasp project!"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell-session"}),"$ wasp new TodoApp\nCreated new Wasp project in ./TodoApp directory!\n")),Object(i.b)("p",null,"Let's inspect created ",Object(i.b)("inlineCode",{parentName:"p"},"TodoApp/")," Wasp project:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell-session"}),"$ tree -al TodoApp\nTodoApp/\n\u251c\u2500\u2500 ext\n\u2502   \u2514\u2500\u2500 MainPage.js\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 main.wasp\n\u2514\u2500\u2500 .wasproot\n")),Object(i.b)("p",null,"Source code files where we will be writing/editing our code are ",Object(i.b)("inlineCode",{parentName:"p"},"main.wasp")," and everything in ",Object(i.b)("inlineCode",{parentName:"p"},"ext/")," dir (for now only ",Object(i.b)("inlineCode",{parentName:"p"},"MainPage.js"),")."),Object(i.b)("p",null,"Let's start the generated project to confirm everything is working as it should (this step might take a little bit longer, due to the first time setup):"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell-session"}),"$ cd TodoApp\n$ wasp start\n")),Object(i.b)("p",null,'This is it!\nYou will be seeing a lot of different output from client, server and database setting themselves up.\nOnce ready, a new tab should open in your browser, at localhost:3000, a white page saying "Hello world!".'),Object(i.b)("p",null,"Let's quickly inspect existing code. We can start with the main (and only) .wasp file:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c",metastring:'title="main.wasp"',title:'"main.wasp"'}),'app TodoApp {\n  title: "Todo app"\n}\n\nroute "/" -> page Main\npage Main {\n  component: import Main from "@ext/MainPage.js"\n}\n')),Object(i.b)("p",null,"Let's see what is hapenning here:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"With ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"/docs/language/basic-elements#app"}),"app")," declaration, we named our web app and specified\nits title (which will be visible in the browser tab)."),Object(i.b)("li",{parentName:"ol"},"With ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"/docs/language/basic-elements#page"}),"page")," declaration, we defined a new page in our app\nnamed ",Object(i.b)("inlineCode",{parentName:"li"},"Main"),", and specified that its ReactJS implementation can be found in\nfile ",Object(i.b)("inlineCode",{parentName:"li"},"ext/MainPage.js")," as a default export."),Object(i.b)("li",{parentName:"ol"},"With ",Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"/docs/language/basic-elements#route"}),"route")," declaration, we defined that page ",Object(i.b)("inlineCode",{parentName:"li"},"Main"),"\nshould be rendered on url ",Object(i.b)("inlineCode",{parentName:"li"},"/"),", effectively making it a default page.")),Object(i.b)("p",null,"Let's check out that React component that we referenced in the ",Object(i.b)("inlineCode",{parentName:"p"},"page Main")," declaration:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx",metastring:'title="ext/MainPage.js"',title:'"ext/MainPage.js"'}),"import React from 'react'\n\nconst MainPage = () => {\n  return <p>Hello world!</p>\n}\nexport default MainPage\n")),Object(i.b)("p",null,'As we can see, this is just a simple functional React component saying "Hello world!".'),Object(i.b)("p",null,"That is all the code right now!\nWasp in the background takes care of everything else needed to define, build and run a web app."),Object(i.b)("p",null,"Now, let's start shaping the app into a Todo App.\n",Object(i.b)("inlineCode",{parentName:"p"},"wasp start")," will automatically pick up changes we make and refresh the app."),Object(i.b)("h2",{id:"task-entity"},"Task Entity"),Object(i.b)("p",null,Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/language/basic-elements#entity"}),"Entities")," are one of the very central concepts in Wasp, and they mainly play the role of data models."),Object(i.b)("p",null,"Since our TodoApp is all about tasks, our first step will be to define Task entity in Wasp:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c",metastring:'title="main.wasp"',title:'"main.wasp"'}),"// ...\nentity Task {=psl\n    id          Int     @id @default(autoincrement())\n    description String\n    isDone      Boolean @default(false)\npsl=}\n")),Object(i.b)("p",null,"Since Wasp delegates database handling to ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.prisma.io"}),"Prisma"),", definition of entity comes down to defining ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/data-model/"}),"Prisma model"),", using PSL (Prisma Schema Language) inside the ",Object(i.b)("inlineCode",{parentName:"p"},"{=psl psl=}")," tags."),Object(i.b)("p",null,"After this change, we need to run"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell-session"}),'$ wasp db migrate-save "added-task-entity"\n')),Object(i.b)("p",null,"to have Prisma propagate the schema changes to the database."),Object(i.b)("h2",{id:"listing-tasks"},"Listing tasks"),Object(i.b)("p",null,"Next, we want to admire our tasks, so let's list them!"),Object(i.b)("p",null,"Main way of interacting with entities in Wasp is ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/language/basic-elements#queries-and-actions-aka-operations"}),"operations (queries and actions)"),"."),Object(i.b)("p",null,"Queries are here when we need to fetch/read something, while actions are here when we need to change/update something.\nIn our case, we will write a query, since we are just listing tasks and not modifying anything."),Object(i.b)("p",null,"First, let's implement ",Object(i.b)("inlineCode",{parentName:"p"},"getTasks")," ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/language/basic-elements#query"}),"query"),".\nIt consists of declaration in Wasp and implementation in JS.",Object(i.b)("br",{parentName:"p"}),"\n","Let's first write the declaration in Wasp:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c",metastring:'title="main.wasp"',title:'"main.wasp"'}),'// ...\nquery getTasks {\n  fn: import { getTasks } from "@ext/queries.js",\n  entities: [Task]\n}\n')),Object(i.b)("p",null,"With this, we define Wasp query ",Object(i.b)("inlineCode",{parentName:"p"},"getTasks")," that uses (does something with) entity ",Object(i.b)("inlineCode",{parentName:"p"},"Task")," (this is declared via ",Object(i.b)("inlineCode",{parentName:"p"},"entities: [Task]"),").\nWe told Wasp that its implementation (which is an async JS function) can be found in ",Object(i.b)("inlineCode",{parentName:"p"},"ext/queries.js"),", exported as named export ",Object(i.b)("inlineCode",{parentName:"p"},"getTasks"),". NOTE: There is no rule that both JS function and Wasp query need to have the same name."),Object(i.b)("p",null,"Next, create a new file ",Object(i.b)("inlineCode",{parentName:"p"},"ext/queries.js")," and define the JS function that we just announced in the declaration above:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:'title="ext/queries.js"',title:'"ext/queries.js"'}),"export const getTasks = async (args, context) => {\n  return context.entities.Task.findMany({})\n}\n")),Object(i.b)("p",null,"All query functions in Wasp take ",Object(i.b)("inlineCode",{parentName:"p"},"args")," object as the first parameter and ",Object(i.b)("inlineCode",{parentName:"p"},"context")," object as the second parameter, where ",Object(i.b)("inlineCode",{parentName:"p"},"args")," are query arguments with which query is called, while ",Object(i.b)("inlineCode",{parentName:"p"},"context")," is additional stuff provided by Wasp.\nSince we declared that query ",Object(i.b)("inlineCode",{parentName:"p"},"getTasks")," uses entity ",Object(i.b)("inlineCode",{parentName:"p"},"Task"),", Wasp injected ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/crud"}),"Prisma client")," for entity Task as ",Object(i.b)("inlineCode",{parentName:"p"},"context.entities.Task"),", which we then used to fetch all the tasks from the database."),Object(i.b)("p",null,"NOTE: Queries and actions are NodeJS and execute on server."),Object(i.b)("p",null,"Finally, let's use the query in our React component to list the tasks:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx",metastring:'{3-4,7-16,19-32} title="ext/MainPage.js"',"{3-4,7-16,19-32}":!0,title:'"ext/MainPage.js"'}),"import React from 'react'\n\nimport getTasks from '@wasp/queries/getTasks'\nimport { useQuery } from '@wasp/queries'\n\nconst MainPage = () => {\n  const { data: tasks, isFetching, error } = useQuery(getTasks)\n\n  return (\n    <div>\n      {tasks && <TasksList tasks={tasks} />}\n\n      {isFetching && 'Fetching...'}\n      {error && 'Error: ' + error}\n    </div>\n  )\n}\n\nconst Task = (props) => (\n  <div>\n    <input\n      type='checkbox' id={props.task.id}\n      checked={props.task.isDone} readonly\n    />\n    {props.task.description}\n  </div>\n)\n\nconst TasksList = (props) => {\n  if (!props.tasks?.length) return 'No tasks'\n  return props.tasks.map((task, idx) => <Task task={task} key={idx} />)\n}\n\nexport default MainPage\n")),Object(i.b)("p",null,"All of this is just normal React, except for the two special ",Object(i.b)("inlineCode",{parentName:"p"},"@wasp")," imports."),Object(i.b)("p",null,"First import, ",Object(i.b)("inlineCode",{parentName:"p"},"import getTasks from '@wasp/queries/getTasks'"),", provides us with the wasp query ",Object(i.b)("inlineCode",{parentName:"p"},"getTasks")," that we previously defined in ",Object(i.b)("inlineCode",{parentName:"p"},"main.wasp"),".\nIn general, rule for importing any Wasp query in JS is to import it as default import and to use ",Object(i.b)("inlineCode",{parentName:"p"},"from")," path of following shape: ",Object(i.b)("inlineCode",{parentName:"p"},"@wasp/queries/<nameOfQuery>"),"."),Object(i.b)("p",null,"While we can, once imported, call the query directly as ",Object(i.b)("inlineCode",{parentName:"p"},"getTasks(args)"),", that would not give us the reactivity that we need - we want React component to automatically re-render if result of ",Object(i.b)("inlineCode",{parentName:"p"},"getTasks")," query changes."),Object(i.b)("p",null,"This is where second import comes in: ",Object(i.b)("inlineCode",{parentName:"p"},"import { useQuery } from '@wasp/queries'"),".\nIt provides us with ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/language/basic-elements#usequery"}),"useQuery")," hook which is actually just a thin wrapper over ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/tannerlinsley/react-query"}),"react-query")," ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://react-query.tanstack.com/docs/guides/queries"}),"useQuery")," hook, behaving very similarly while offering some extra integration with Wasp, which we are going to cover later. By calling the query via this hook (",Object(i.b)("inlineCode",{parentName:"p"},"useQuery(getTasks)"),"), we get the reactivity that we wanted."),Object(i.b)("p",null,'With these changes, you should be seeing text "No tasks" on the screen.'),Object(i.b)("p",null,"Next, let's create some tasks!"),Object(i.b)("h2",{id:"creating-new-tasks"},"Creating new tasks"),Object(i.b)("p",null,"To enable creation of new tasks, we will need two things:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Wasp action that creates new task."),Object(i.b)("li",{parentName:"ol"},"React form that calls that action.")),Object(i.b)("h3",{id:"wasp-action"},"Wasp action"),Object(i.b)("p",null,"Creating an action is very similar to creating a query."),Object(i.b)("p",null,"First we declare the action in Wasp:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c",metastring:'title="main.wasp"',title:'"main.wasp"'}),'// ...\naction createTask {\n  fn: import { createTask } from "@ext/actions.js",\n  entities: [Task]\n}\n')),Object(i.b)("p",null,"Next, we define JS function for that action:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:'title="ext/actions.js"',title:'"ext/actions.js"'}),"export const createTask = async (args, context) => {\n  return context.entities.Task.create({\n    data: { description: args.description }\n  })\n}\n")),Object(i.b)("p",null,"NOTE: We put it in new file ",Object(i.b)("inlineCode",{parentName:"p"},"ext/actions.js"),", but we could have put it anywhere we wanted, there are no limitations here, as long as import statement in Wasp file is correct and it is inside the ",Object(i.b)("inlineCode",{parentName:"p"},"ext/")," dir."),Object(i.b)("h3",{id:"react-form"},"React form"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx",metastring:'{1,5,12,37-61} title="ext/MainPage.js"',"{1,5,12,37-61}":!0,title:'"ext/MainPage.js"'}),"import React, { useState } from 'react'\n\nimport { useQuery } from '@wasp/queries'\nimport getTasks from '@wasp/queries/getTasks'\nimport createTask from '@wasp/actions/createTask'\n\nconst MainPage = () => {\n  const { data: tasks, isFetching, error } = useQuery(getTasks)\n\n  return (\n    <div>\n      <NewTaskForm />\n\n      {tasks && <TasksList tasks={tasks} />}\n\n      {isFetching && 'Fetching...'}\n      {error && 'Error: ' + error}\n    </div>\n  )\n}\n\nconst Task = (props) => {\n  return (\n    <div>\n      <input\n        type='checkbox' id={props.task.id}\n        checked={props.task.isDone} readonly\n      />\n      {props.task.description}\n    </div>\n  )\n}\n\nconst TasksList = (props) => {\n  if (!props.tasks?.length) return 'No tasks'\n  return props.tasks.map((task, idx) => <Task task={task} key={idx} />)\n}\n\nconst NewTaskForm = (props) => {\n  const defaultDescription = ''\n  const [description, setDescription] = useState(defaultDescription)\n\n  const handleSubmit = async (event) => {\n    event.preventDefault()\n    try {\n      await createTask({ description })\n      setDescription(defaultDescription)\n    } catch (err) {\n      window.alert('Error: ' + err.message)\n    }\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type='text'\n        value={description}\n        onChange={e => setDescription(e.target.value)}\n      />\n      <input type='submit' value='Create task' />\n    </form>\n  )\n}\n\nexport default MainPage\n")),Object(i.b)("p",null,"Here we call action directly (no hooks), since there is no reactivity that we need from it, which is also why we need to catch errors if there are any. The rest is just normal React code."),Object(i.b)("p",null,'This is it! Try creating a "Build a Todo App in Wasp" task and you will see it appear in the list below.'),Object(i.b)("h3",{id:"automatic-invalidationupdating-of-queries"},"Automatic invalidation/updating of queries"),Object(i.b)("p",null,"You will notice that when you create a new task, list of tasks is automatically updated with that new task, although we have written no code to take care of that! Normally, you would have to do this explicitly, e.g. with react-query you would invalidate the ",Object(i.b)("inlineCode",{parentName:"p"},"getTasks")," query via its key, or would call its ",Object(i.b)("inlineCode",{parentName:"p"},"refetch()")," method."),Object(i.b)("p",null,"The reason why ",Object(i.b)("inlineCode",{parentName:"p"},"getTasks")," query automatically updates when ",Object(i.b)("inlineCode",{parentName:"p"},"createTask")," action is executed is because Wasp is aware that both of them are working with ",Object(i.b)("inlineCode",{parentName:"p"},"Task")," entity, and therefore assumes that action that operates on ",Object(i.b)("inlineCode",{parentName:"p"},"Task")," (in this case ",Object(i.b)("inlineCode",{parentName:"p"},"createTask"),") might have changed the result of ",Object(i.b)("inlineCode",{parentName:"p"},"getTasks")," query. Therefore, in the background, Wasp nudges `getTasks** query to update. This means that out of the box, Wasp will make sure that all your queries that deal with entities are always in sync with any changes that actions might have done."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"NOTE"),": While this kind of approach to automatic invalidation of queries is very convenient, it is in some situations wasteful and could become a performance bottleneck as app grows. In that case, you will be able to override this default behaviour and instead provide more detailed (and performant) instructions on how action should affect queries. This is not yet implemented, but is something we plan to do and you can track the progress ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/wasp-lang/wasp/issues/63"}),"here")," (or even contribute!)."),Object(i.b)("h2",{id:"updating-tasks"},"Updating tasks"),Object(i.b)("p",null,"Todo app would be very frustrating if you couldn't mark a task as done!"),Object(i.b)("p",null,"For that, we will need to do two things:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Implement Wasp action that updates the task."),Object(i.b)("li",{parentName:"ol"},"Modify React component so it calls that action.")),Object(i.b)("p",null,"We declare Wasp action:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c",metastring:'title="main.wasp"',title:'"main.wasp"'}),'// ...\naction updateTask {\n  fn: import { updateTask } from "@ext/actions.js",\n  entities: [Task]\n}\n')),Object(i.b)("p",null,"We define JS implementation of Wasp action in ",Object(i.b)("inlineCode",{parentName:"p"},"ext/actions.js")," file:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:'title="ext/actions.js"',title:'"ext/actions.js"'}),"// ...\nexport const updateTask = async (args, context) => {\n  return context.entities.Task.update({\n    where: { id: args.taskId },\n    data: {\n      isDone: args.data.isDone\n    }\n  })\n}\n")),Object(i.b)("p",null,"And we update React component:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx",metastring:'{2,7-16,23} title="ext/MainPage.js"',"{2,7-16,23}":!0,title:'"ext/MainPage.js"'}),"// ...\nimport updateTask from '@wasp/actions/updateTask'\n\n// ...\n\nconst Task = (props) => {\n  const handleIsDoneChange = async (event) => {\n    try {\n      await updateTask({\n        taskId: props.task.id,\n        data: { isDone: event.target.checked }\n      })\n    } catch (error) {\n      window.alert('Error while updating task: ' + error.message)\n    }\n  }\n\n  return (\n    <div>\n      <input\n        type='checkbox' id={props.task.id}\n        checked={props.task.isDone} readonly\n        onChange={handleIsDoneChange}\n      />\n      {props.task.description}\n    </div>\n  )\n}\n// ...\n")),Object(i.b)("p",null,"Aesome! We can tick this task as done ;)."),Object(i.b)("h2",{id:"clocks"},"Clocks"),Object(i.b)("p",null,"What is a Todo app without some clocks!? Well, still a Todo app, but certainly not as fun as one with the clocks."),Object(i.b)("p",null,"So, let's add a couple of clocks to our app, to help us track time while we perform our tasks (and to demonstrate a couple more of Wasp features :))."),Object(i.b)("p",null,"For this, we will use ",Object(i.b)("inlineCode",{parentName:"p"},"react-clock")," library from NPM. We can add it to our project as a ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/language/basic-elements#dependencies"}),"dependency")," like this:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c",metastring:'title="main.wasp"',title:'"main.wasp"'}),'// ...\ndependencies {=json\n  "react-clock": "3.0.0"\njson=}\n')),Object(i.b)("p",null,"Next, let's create a ",Object(i.b)("inlineCode",{parentName:"p"},"Clocks")," component where we can play with the clocks."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx",metastring:'title="ext/Clocks.js"',title:'"ext/Clocks.js"'}),"import React, { useEffect, useState } from 'react'\nimport Clock from 'react-clock'\nimport 'react-clock/dist/Clock.css'\n\nexport default () => {\n  const [time, setTime] = useState(new Date())\n  \n  useEffect(() => {\n    const interval = setInterval(() => setTime(new Date()), 1000)\n    return () => clearInterval(interval)\n  }, [])\n  \n  return (\n    <div style={{ display: 'flex' }}>\n      <Clock value={time} />\n      <Clock value={new Date(time.getTime() + 60 * 60000)} />\n    </div>\n  )\n}\n")),Object(i.b)("p",null,"And let's import it in our main React component."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx",metastring:'{2,13} title="ext/MainPage.js"',"{2,13}":!0,title:'"ext/MainPage.js"'}),"// ...\nimport Clocks from './Clocks'\n\nconst MainPage = () => {\n  const { data: tasks, isFetching, error } = useQuery(getTasks)\n\n  return (\n    <div>\n      <NewTaskForm />\n\n      {tasks && <TasksList tasks={tasks} />}\n\n      <p> <Clocks /> </p>\n\n      {isFetching && 'Fetching...'}\n      {error && 'Error: ' + error}\n    </div>\n  )\n}\n// ...\n")),Object(i.b)("p",null,"As you can see, importing other files from ",Object(i.b)("inlineCode",{parentName:"p"},"/ext")," is completely normal, just use relative path."),Object(i.b)("h2",{id:"user--authentication"},"User + authentication"),Object(i.b)("p",null,"Most of the apps today are multi-user, and Wasp has first-class support for it, so let's see how to add it to our Todo app!"),Object(i.b)("p",null,"Let's define a Todo list (luckily we have an app for that now!) to get this done:"),Object(i.b)("ul",{className:"contains-task-list"},Object(i.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(i.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!1,disabled:!0}))," ","Add Wasp entity ",Object(i.b)("inlineCode",{parentName:"li"},"User"),"."),Object(i.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(i.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!1,disabled:!0}))," ","Add ",Object(i.b)("inlineCode",{parentName:"li"},"auth")," Wasp declaration."),Object(i.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(i.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!1,disabled:!0}))," ","Create ",Object(i.b)("inlineCode",{parentName:"li"},"signUp")," action."),Object(i.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(i.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!1,disabled:!0}))," ","Create ",Object(i.b)("inlineCode",{parentName:"li"},"Auth")," page where users will login/signup (React component + Wasp page declaration + Wasp route declaration)."),Object(i.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(i.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!1,disabled:!0}))," ","Modify ",Object(i.b)("inlineCode",{parentName:"li"},"ext/MainPage.js")," so that it requires login/signup."),Object(i.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(i.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!1,disabled:!0}))," ","Add Prisma relation between ",Object(i.b)("inlineCode",{parentName:"li"},"User")," and ",Object(i.b)("inlineCode",{parentName:"li"},"Task")," entities."),Object(i.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(i.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!1,disabled:!0}))," ","Modify our queries and actions so that they work only with the tasks belonging to the authenticated user."),Object(i.b)("li",Object(a.a)({parentName:"ul"},{className:"task-list-item"}),Object(i.b)("input",Object(a.a)({parentName:"li"},{type:"checkbox",checked:!1,disabled:!0}))," ","Add logout button.")),Object(i.b)("p",null,"First, let's define entity ",Object(i.b)("inlineCode",{parentName:"p"},"User"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c",metastring:'title="main.wasp"',title:'"main.wasp"'}),"// ...\nentity User {=psl\n    id          Int     @id @default(autoincrement())\n    email       String  @unique\n    password    String\npsl=}\n// ...\n")),Object(i.b)("p",null,"Next, we want to tell Wasp that we want ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/language/basic-elements#authentication--authorization"}),"authentication")," (via email and password) in our app, and that it should use entity ",Object(i.b)("inlineCode",{parentName:"p"},"User")," for it. ",Object(i.b)("inlineCode",{parentName:"p"},"auth")," expects given entity to have ",Object(i.b)("inlineCode",{parentName:"p"},"email: String")," and ",Object(i.b)("inlineCode",{parentName:"p"},"password: String")," fields, which ",Object(i.b)("inlineCode",{parentName:"p"},"User")," has."),Object(i.b)("p",null,"We do that by adding the ",Object(i.b)("inlineCode",{parentName:"p"},"auth")," declaration:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c",metastring:'title="main.wasp"',title:'"main.wasp"'}),"// ...\nauth {\n  userEntity: User,\n  methods: [ EmailAndPassword ]\n}\n// ...\n")),Object(i.b)("p",null,"What this means for us is that Wasp now offers us:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Function ",Object(i.b)("inlineCode",{parentName:"li"},"createNewUser()")," on client."),Object(i.b)("li",{parentName:"ul"},"Actions ",Object(i.b)("inlineCode",{parentName:"li"},"login()")," and ",Object(i.b)("inlineCode",{parentName:"li"},"logout()"),"."),Object(i.b)("li",{parentName:"ul"},"React hook ",Object(i.b)("inlineCode",{parentName:"li"},"useAuth()"),"."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"context.user")," when in query/action.")),Object(i.b)("p",null,"Before we start with React, let's first add one more action: ",Object(i.b)("inlineCode",{parentName:"p"},"signUp"),".\nIt will be just a wrapper for ",Object(i.b)("inlineCode",{parentName:"p"},"createNewUser()")," for now, but it does one important thing: it declares that it uses ",Object(i.b)("inlineCode",{parentName:"p"},"User")," entity, so our queries will be correctly updated/invalidated when we sign up new user via ",Object(i.b)("inlineCode",{parentName:"p"},"signUp")," action."),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c",metastring:'title="main.wasp"',title:'"main.wasp"'}),'// ...\naction signUp {\n  fn: import { signUp } from "@ext/actions.js",\n  entities: [User]\n}\n// ...\n')),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:'title="ext/actions.js"',title:'"ext/actions.js"'}),"// ...\nimport { createNewUser } from '@wasp/core/auth.js'\n\n// ...\n\nexport const signUp = async ({ email, password }, context) => {\n  await createNewUser({ email, password })\n}\n")),Object(i.b)("p",null,"Ok, that was easy!"),Object(i.b)("p",null,"To recap, so far we have created:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"User")," entity."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"auth")," declaration thanks to which Wasp gives us plenty of auth functionality."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"signUp")," action, via which we can create new user.")),Object(i.b)("p",null,"Now, let's consider how are we going to handle the situation when user is not logged in.\nWhat we can do is check in the MainPage.js if user is logged in.\nIf not, we will instruct them to go to the special ",Object(i.b)("inlineCode",{parentName:"p"},"/auth")," page where they can sign up or log in.\nIf they succeed, we will send them back to the ",Object(i.b)("inlineCode",{parentName:"p"},"/")," (MainPage.js).\nWhile approach like this would be overly-simplistic for the real-world app, it will serve us well for this simple tutorial!"),Object(i.b)("p",null,"First, let's define the ",Object(i.b)("inlineCode",{parentName:"p"},"Auth")," page, where we will use ",Object(i.b)("inlineCode",{parentName:"p"},"signUp")," and ",Object(i.b)("inlineCode",{parentName:"p"},"login")," actions to signup/login a new user."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Auth")," page declaration in Wasp:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c",metastring:'title="main.wasp"',title:'"main.wasp"'}),'// ...\nroute "/auth" -> page Auth \npage Auth {\n    component: import AuthPage from "@ext/AuthPage.js"\n}\n// ...\n')),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Auth")," page React component (lot of code, but most of it is just form):"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx",metastring:'title="ext/AuthPage.js"',title:'"ext/AuthPage.js"'}),"import React, { useState } from 'react'\nimport { useHistory } from 'react-router-dom'\n\nimport signUp from '@wasp/actions/signUp.js'\nimport login from '@wasp/auth/login.js'\n\nexport default () => {\n  const [method, setMethod] = useState('login')\n\n  const toggleMethod = () => {\n    setMethod(method === 'login' ? 'signup' : 'login')\n  }\n\n  return (\n    <>\n      <AuthForm method={method} />\n      <a href='javascript:;' onClick={toggleMethod}>\n        {method === 'login'\n          ? 'I don\\'t have an account yet (go to sign up).'\n          : 'I already have an account (go to log in).'}\n      </a>\n    </>\n  )\n}\n\nconst AuthForm = (props) => {\n  const history = useHistory()\n  const [email, setEmail] = useState('')\n  const [password, setPassword] = useState('')\n\n  const handleSubmit = async (event) => {\n    event.preventDefault()\n    try {\n      if (props.method === 'signup') {\n        await signUp({ email, password })\n      }\n      await login(email, password)\n      history.push('/')\n    } catch (err) {\n      window.alert('Error:' + err.message)\n    }\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <h2>Email</h2>\n      <input\n        type='text'\n        value={email}\n        onChange={e => setEmail(e.target.value)}\n      />\n      <h2>Password</h2>\n      <input\n        type='password'\n        value={password}\n        onChange={e => setPassword(e.target.value)}\n      />\n      <div>\n        <input type='submit' value={props.method === 'signup' ? 'Sign up' : 'Log in'} />\n      </div>\n    </form>\n  )\n}\n")),Object(i.b)("p",null,"Finally, let's modify ",Object(i.b)("inlineCode",{parentName:"p"},"MainPage.js")," so that it sends user to Auth page if they are not logged in:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx",metastring:'{2-3,8-11} title="ext/MainPage.js"',"{2-3,8-11}":!0,title:'"ext/MainPage.js"'}),"// ...\nimport { Link } from 'react-router-dom'\nimport useAuth from '@wasp/auth/useAuth.js'\n// ...\n\nconst MainPage = () => {\n  // ...\n  const { data: user } = useAuth()\n  if (!user) {\n    return <span> Please <Link to='/auth'>log in</Link>. </span>\n  }\n  // ...\n}\n// ...\n")),Object(i.b)("p",null,"Ok, time to try out how this works!"),Object(i.b)("p",null,"Since we modified entities (added ",Object(i.b)("inlineCode",{parentName:"p"},"User")," entity), we need to first run"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell-session"}),'$ wasp db migrate-save "added-user"\n')),Object(i.b)("p",null,"Now, we can run ",Object(i.b)("inlineCode",{parentName:"p"},"wasp start")," as usual."),Object(i.b)("p",null,"Try going to ",Object(i.b)("inlineCode",{parentName:"p"},"/")," in our web app -> it will now ask you to log in, and if you follow the link, you will end up at ",Object(i.b)("inlineCode",{parentName:"p"},"/auth"),".\nOnce you log in or sign up, you will be sent back to ",Object(i.b)("inlineCode",{parentName:"p"},"/")," and you will see the todo list."),Object(i.b)("p",null,"However, you will notice, if you try logging in with different users and creating tasks, that all users are still sharing tasks.\nThat is because we did not yet update queries and actions to work only on current user's tasks, so let's do that next!"),Object(i.b)("p",null,"First, let's define User-Task relation (check ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema/relations"}),"prisma docs on relations"),"):"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c",metastring:'{6,13-14} title="main.wasp"',"{6,13-14}":!0,title:'"main.wasp"'}),"// ...\nentity User {=psl\n    id          Int     @id @default(autoincrement())\n    email       String  @unique\n    password    String\n    tasks       Task[]\npsl=}\n// ...\nentity Task {=psl\n    id          Int     @id @default(autoincrement())\n    description String\n    isDone      Boolean @default(false)\n    user        User?    @relation(fields: [userId], references: [id])\n    userId      Int?\npsl=}\n// ...\n")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"NOTE"),": We made ",Object(i.b)("inlineCode",{parentName:"p"},"user")," and ",Object(i.b)("inlineCode",{parentName:"p"},"userId")," in ",Object(i.b)("inlineCode",{parentName:"p"},"Task")," optional (via ",Object(i.b)("inlineCode",{parentName:"p"},"?"),") because that allows us to keep the existing tasks, which don't have a user assigned, in the database.\nThis is not recommended because it allows unwanted state in the database (what is the purpose of the task not belonging to anybody?) and normally we would not make these fields optional.\nInstead, we would do a data migration to take care of those tasks, even if it means just deleting them all.\nHowever, for this tutorial, for the sake of simplicity, we will stick with this."),Object(i.b)("p",null,"Next, let's update the queries and actions to forbid access to non-authenticated users and to operate only on user's tasks:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:'{1,4,6} title="ext/queries.js"',"{1,4,6}":!0,title:'"ext/queries.js"'}),"import HttpError from '@wasp/core/HttpError.js'\n\nexport const getTasks = async (args, context) => {\n  if (!context.user) { throw new HttpError(403) }\n  return context.entities.Task.findMany(\n    { where: { user: { id: context.user.id } } }\n  )\n}\n")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js",metastring:'{1,5,9,15,16,17} title="ext/actions.js"',"{1,5,9,15,16,17}":!0,title:'"ext/actions.js"'}),"import HttpError from '@wasp/core/HttpError.js'\nimport { createNewUser } from '@wasp/core/auth.js'\n\nexport const createTask = async ({ description }, context) => {\n  if (!context.user) { throw new HttpError(403) }\n  return context.entities.Task.create({\n    data: {\n      description,\n      user: { connect: { id: context.user.id } }\n    }\n  })\n}\n\nexport const updateTask = async ({ taskId, data }, context) => {\n  if (!context.user) { throw new HttpError(403) }\n  return context.entities.Task.updateMany({\n    where: { id: taskId, user: { id: context.user.id } },\n    data: { isDone: data.isDone }\n  })\n}\n\nexport const signUp = async ({ email, password }, context) => {\n  await createNewUser({ email, password })\n}\n")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"NOTE"),": Due to how Prisma works, we had to convert ",Object(i.b)("inlineCode",{parentName:"p"},"update")," to ",Object(i.b)("inlineCode",{parentName:"p"},"updateMany")," in ",Object(i.b)("inlineCode",{parentName:"p"},"updateTask")," action to be able to specify user id in ",Object(i.b)("inlineCode",{parentName:"p"},"where"),"."),Object(i.b)("p",null,"Right, that should be it!"),Object(i.b)("p",null,"We modified entities by adding User-Task relation, so let's run"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-shell-session"}),'$ wasp db migrate-save "user-task-relation"\n')),Object(i.b)("p",null,"to create a db schema migration.\nRun ",Object(i.b)("inlineCode",{parentName:"p"},"wasp start")," and everything should work as expected now!\nEach user has their own tasks only they can see and edit."),Object(i.b)("p",null,"Last, but not the least, let's add logout functionality:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx",metastring:'{2,10} title="MainPage.js"',"{2,10}":!0,title:'"MainPage.js"'}),"// ...\nimport logout from '@wasp/auth/logout.js'\n//...\n\nconst MainPage = () => {\n  // ...\n  return (\n    <div>\n      // ...\n      <button onClick={logout}> Logout </button>\n    </div>\n  )\n}\n// ...\n")),Object(i.b)("p",null,"This is it, we have working authentication system and our app is multi-user!"),Object(i.b)("h2",{id:"the-end"},"The End"),Object(i.b)("p",null,'We did it! For all those that followed the instructions closely and created "Build a Todo App in Wasp" task in our Todo App, let\'s celebrate by marking it as done :)!'),Object(i.b)("img",{alt:"Yay we are done with the Todo App tutorial!",src:Object(s.a)("img/todo-app-tutorial-end.gif"),style:{border:"1px solid black"}}),Object(i.b)("p",null,"You can check out the whole code of the app that we just built ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/wasp-lang/wasp/tree/master/examples/tutorials/TodoApp"}),"here"),"."),Object(i.b)("p",null,"If you are interested in what is Wasp actually generating in the background, you can check ",Object(i.b)("inlineCode",{parentName:"p"},".wasp/out/")," directory in your project."),Object(i.b)("p",null,"Where from here?",Object(i.b)("br",{parentName:"p"}),"\n",'Well, you could check the "Language" section of the docs for more details on specific parts of Wasp.',Object(i.b)("br",{parentName:"p"}),"\n","Or, you could try to build something on your own with Wasp!",Object(i.b)("br",{parentName:"p"}),"\n","You are likely to find that some feature that you want is missing, since Wasp is still in alpha.\nIn that case, please write to us on ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://discord.gg/rzdnErX"}),"Discord")," or create an issue on ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/wasp-lang/wasp"}),"Github"),", so we can learn which features to add.",Object(i.b)("br",{parentName:"p"}),"\n","Even beter, if you would like to contribute or help building the feature, let us know!\nYou can find more details about contributing ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/contributing"}),"here"),"."))}p.isMDXComponent=!0},74:function(e,t,n){"use strict";var a=n(0),i=n(21);t.a=function(){const e=Object(a.useContext)(i.a);if(null===e)throw new Error("Docusaurus context not provided");return e}},75:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return m}));var a=n(0),i=n.n(a);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=i.a.createContext({}),p=function(e){var t=i.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},b=function(e){var t=p(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},d=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,r=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),b=p(n),d=a,m=b["".concat(r,".").concat(d)]||b[d]||u[d]||s;return n?i.a.createElement(m,o(o({ref:t},l),{},{components:n})):i.a.createElement(m,o({ref:t},l))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,r=new Array(s);r[0]=d;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,r[1]=o;for(var l=2;l<s;l++)r[l]=n[l];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},77:function(e,t,n){"use strict";n.d(t,"b",(function(){return s})),n.d(t,"a",(function(){return r}));var a=n(74),i=n(79);function s(){const{siteConfig:{baseUrl:e="/",url:t}={}}=Object(a.a)();return{withBaseUrl:(n,a)=>function(e,t,n,{forcePrependBaseUrl:a=!1,absolute:s=!1}={}){if(!n)return n;if(n.startsWith("#"))return n;if(Object(i.b)(n))return n;if(a)return t+n;const r=n.startsWith(t)?n:t+n.replace(/^\//,"");return s?e+r:r}(t,e,n,a)}}function r(e,t={}){const{withBaseUrl:n}=s();return n(e,t)}},79:function(e,t,n){"use strict";function a(e){return!0===/^(\w*:|\/\/)/.test(e)}function i(e){return void 0!==e&&!a(e)}n.d(t,"b",(function(){return a})),n.d(t,"a",(function(){return i}))}}]);