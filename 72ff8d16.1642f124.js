(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{61:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return o})),a.d(t,"metadata",(function(){return s})),a.d(t,"rightToc",(function(){return c})),a.d(t,"default",(function(){return l}));var n=a(2),r=a(6),i=(a(0),a(74)),o={title:"Basic Elements"},s={unversionedId:"language/basic-elements",id:"language/basic-elements",isDocsHomePage:!1,title:"Basic Elements",description:"App",source:"@site/docs/language/basic-elements.md",slug:"/language/basic-elements",permalink:"/web/docs/language/basic-elements",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/language/basic-elements.md",version:"current",sidebar:"docs",previous:{title:"Overview",permalink:"/web/docs/language/overview"}},c=[{value:"App",id:"app",children:[]},{value:"Page",id:"page",children:[]},{value:"Route",id:"route",children:[{value:"Example - parametrised URL path",id:"example---parametrised-url-path",children:[]},{value:"Accessing route parameters in a page component",id:"accessing-route-parameters-in-a-page-component",children:[]},{value:"Navigating between routes",id:"navigating-between-routes",children:[]}]},{value:"Entity",id:"entity",children:[{value:"Using entities",id:"using-entities",children:[]}]},{value:"Queries and Actions (aka Operations)",id:"queries-and-actions-aka-operations",children:[{value:"Query",id:"query",children:[]},{value:"Action",id:"action",children:[]}]}],p={rightToc:c};function l(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},p,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"app"},"App"),Object(i.b)("p",null,"There can be only one ",Object(i.b)("inlineCode",{parentName:"p"},"App")," element per Wasp project. It serves as a starting point and defines global\nproperties of your app. Currently, it is very simple:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-css"}),'app todoApp {\n    title: "ToDo App"\n}\n')),Object(i.b)("h4",{id:"app-identifier"},Object(i.b)("inlineCode",{parentName:"h4"},"app: identifier")),Object(i.b)("p",null,"Name of your app."),Object(i.b)("h4",{id:"title-string"},Object(i.b)("inlineCode",{parentName:"h4"},"title: string")),Object(i.b)("p",null,"Title of your app. It will be displayed in the browser tab, next to the favicon."),Object(i.b)("h2",{id:"page"},"Page"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Page")," is the top-level layout abstraction. Your app can have multiple pages, and they are defined in Wasp\nas follows:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-css"}),'page Main {\n    component: import Main from "@ext/pages/Main"\n}\n')),Object(i.b)("h4",{id:"page-identifier"},Object(i.b)("inlineCode",{parentName:"h4"},"page: identifier")),Object(i.b)("p",null,"Name of the page."),Object(i.b)("h4",{id:"component-js-import-statement"},Object(i.b)("inlineCode",{parentName:"h4"},"component: js import statement")),Object(i.b)("p",null,"Import statement of the page React element. See importing external code for details."),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Page")," also has to be associated with a ",Object(i.b)("inlineCode",{parentName:"p"},"Route"),", otherwise it won't be accessible in the app."),Object(i.b)("h2",{id:"route"},"Route"),Object(i.b)("p",null,"Using ",Object(i.b)("inlineCode",{parentName:"p"},"Route")," element is a way to implement routing functionality in Wasp:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-css"}),'route "/about" -> page About\n')),Object(i.b)("h4",{id:"route-string"},Object(i.b)("inlineCode",{parentName:"h4"},"route: string")),Object(i.b)("p",null,"URL path of the route. Route string can be parametrised and follows the same conventions as\n",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://reactrouter.com/web/"}),"React Router"),"."),Object(i.b)("h4",{id:"page-page-identifier"},Object(i.b)("inlineCode",{parentName:"h4"},"page: page identifier")),Object(i.b)("p",null,"Page identifier of the route's target. Referenced page must be defined somewhere in ",Object(i.b)("inlineCode",{parentName:"p"},".wasp")," file."),Object(i.b)("h3",{id:"example---parametrised-url-path"},"Example - parametrised URL path"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-css"}),'route "/task/:id" -> page Task\n')),Object(i.b)("p",null,"For details on URL path format check ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://reactrouter.com/web/"}),"React Router"),"\ndocumentation."),Object(i.b)("h3",{id:"accessing-route-parameters-in-a-page-component"},"Accessing route parameters in a page component"),Object(i.b)("p",null,"Since Wasp under the hood generates code with ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://reactrouter.com/web/"}),"React Router"),",\nthe same rules apply when accessing URL params in your React components. Here is an example just to get you\nstarted:"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"todoApp.wasp")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-css"}),'route "/task/:id" -> page Task\npage Task {\n    component: import Task from "@ext/pages/Task"\n}\n')),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"pages/Task.js")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),"import React from 'react'\n\nconst Task = (props) => {\n  return (\n    <div>\n      I am showing a task with id: {props.match.params.id}.\n    </div>\n  )\n}\n\nexport default Task\n")),Object(i.b)("h3",{id:"navigating-between-routes"},"Navigating between routes"),Object(i.b)("p",null,"Navigation can be performed from the React code via ",Object(i.b)("inlineCode",{parentName:"p"},"<Link/>")," component, also using the functionality of\n",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://reactrouter.com/web/"}),"React Router"),":"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"todoApp.wasp")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-css"}),'route "/home" -> page Home\npage Home {\n    component: import Home from "@ext/pages/Home"\n}\n')),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"pages/OtherPage.js")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-jsx"}),'import React from \'react\'\nimport { Link } from "react-router-dom"\n\nconst OtherPage = (props) => {\n  return (\n    <Link to="/home">Go to homepage</Link>\n  )\n}\n')),Object(i.b)("h2",{id:"entity"},"Entity"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"Entity")," element represents a database model. Wasp uses ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.prisma.io/"}),"Prisma")," to implement\ndatabase functionality and currently provides only a thin layer above it."),Object(i.b)("p",null,"Each ",Object(i.b)("inlineCode",{parentName:"p"},"Entity")," element corresponds 1-to-1 to Prisma data model and is defined in a following way:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-css"}),"entityPSL Task {=psl\n    id          Int     @id @default(autoincrement())\n    description String\n    isDone      Boolean @default(false)\npsl=}\n")),Object(i.b)("h4",{id:"entitypsl-identifier"},Object(i.b)("inlineCode",{parentName:"h4"},"entityPSL: identifier")),Object(i.b)("p",null,"Name of the entity."),Object(i.b)("h4",{id:"psl--psl-psl"},Object(i.b)("inlineCode",{parentName:"h4"},"{=psl ... psl=}: PSL")),Object(i.b)("p",null,"Definition of entity fields in ",Object(i.b)("em",{parentName:"p"},"Prisma Schema Language")," (PSL). See\n",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-schema"}),"here for intro and examples"),"\nand ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/prisma/specs/tree/master/schema"}),"here for a more exhaustive language specification"),"."),Object(i.b)("h3",{id:"using-entities"},"Using entities"),Object(i.b)("p",null,"Entity-system in Wasp is based on ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://www.prisma.io"}),"Prisma"),", and currently Wasp provides only a thin layer\non top of it. The workflow is as follows:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Wasp developer creates/updates some of the entities in ",Object(i.b)("inlineCode",{parentName:"li"},".wasp")," file"),Object(i.b)("li",{parentName:"ol"},"Wasp developer runs ",Object(i.b)("inlineCode",{parentName:"li"},"wasp db migrate-save <migration_name>")),Object(i.b)("li",{parentName:"ol"},"Migration data is generated in ",Object(i.b)("inlineCode",{parentName:"li"},"migrations/")," folder (and should be commited)"),Object(i.b)("li",{parentName:"ol"},"Wasp developer uses Prisma JS API to query the database")),Object(i.b)("p",null,"This is an example of how to import database JS API and use to make a simple database query:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"import Prisma from '@prisma/client'\n\nconst prisma = new Prisma.PrismaClient()\n\nexport const getTasks = async (args, context) => {\n  const tasks = await prisma.task.findMany({})\n\n  return tasks\n}\n")),Object(i.b)("h2",{id:"queries-and-actions-aka-operations"},"Queries and Actions (aka Operations)"),Object(i.b)("p",null,"In Wasp, main interaction between client and server happens via Operations, of which two types exist: Queries and Actions."),Object(i.b)("h3",{id:"query"},"Query"),Object(i.b)("p",null,"Queries are NodeJS functions that don't modify any state. Normally they fetch certain resources, process them and return result."),Object(i.b)("p",null,"To create a Wasp Query, you need a NodeJS function"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),'// file: ext/foo.js\n\nexport getAllTasks = async (args, context) => {\n  return [\n    { description: "Buy some eggs", isDone: true },\n    { description: "Make an omelette", isDone: false }\n  ]\n}\n')),Object(i.b)("p",null,"and a ",Object(i.b)("inlineCode",{parentName:"p"},"query")," declaration in Wasp"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),'// file: main.wasp\n\nquery getTasks {\n  fn: import { getAllTasks } from "@ext/foo.js"\n}\n')),Object(i.b)("p",null,"NodeJS function above has to be async and will be passed query arguments as first argument and additional context as second argument."),Object(i.b)("p",null,"By declaring a NodeJS function as a Wasp query, following happens:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Wasp generates HTTP API route on the NodeJS server that calls the query function."),Object(i.b)("li",{parentName:"ul"},"Wasp generates JS function on the client that has the name under which query was declared and takes same arguments as the NodeJS query function. Internally it uses above mentioned HTTP API route to call the NodeJS query function.")),Object(i.b)("p",null,"On client, you can import generated query JS function as ",Object(i.b)("inlineCode",{parentName:"p"},"import getTasks from '@wasp/queries/getTasks.js'"),".\nThen, you can either use it directly, or you can use it via special ",Object(i.b)("inlineCode",{parentName:"p"},"useQuery")," React hook (provided by Wasp) to make it reactive."),Object(i.b)("p",null,"On server, you can just use it directly (",Object(i.b)("inlineCode",{parentName:"p"},'import { getAllTasks } from "@ext/foo.js"'),")."),Object(i.b)("h4",{id:"usequery"},"useQuery"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"useQuery")," hook provided by Wasp is actually just a thin wrapper for ",Object(i.b)("inlineCode",{parentName:"p"},"useQuery")," hook from ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/tannerlinsley/react-query"}),"react-query"),"."),Object(i.b)("p",null,"You can import it as ",Object(i.b)("inlineCode",{parentName:"p"},"import { useQuery } from '@wasp/queries'"),"."),Object(i.b)("p",null,"Wasp ",Object(i.b)("inlineCode",{parentName:"p"},"useQuery")," takes three args:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"queryFn")," -> client query function generated by Wasp based on query declaration, e.g. one from '@wasp/queries/getTasks.js'"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"queryFnArgs")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"config")," -> react-query ",Object(i.b)("inlineCode",{parentName:"li"},"config"),".")),Object(i.b)("p",null,"It behaves exactly the same as ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://react-query.tanstack.com/docs/api#usequery"}),"useQuery from react-query"),", only it doesn't take the key, that is handled automatically instead."),Object(i.b)("p",null,"Example of usage:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"import React from 'react'\nimport { useQuery } from '@wasp/queries'\nimport getTasks from '@wasp/queries/getTasks'\n\nconst MyComponent = (props) => {\n  const { data: tasks, error } = useQuery(getTasks)\n  return <div> { JSON.stringify(tasks || error) } </div>\n}\n")),Object(i.b)("h4",{id:"error-handling"},"Error handling"),Object(i.b)("p",null,"For security reasons, all errors thrown in the query NodeJS function are sent to client via HTTP API as 500 errors, with any further details removed, so that any unpredicted errors don't make it out with possibly sensitive data."),Object(i.b)("p",null,"If you do want to throw an error that will pass some information to the client, you can use ",Object(i.b)("inlineCode",{parentName:"p"},"HttpError")," in your NodeJS query function:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"import HttpError from '@wasp/core/HttpError'\n\nexport getTasks = async (args, context) => {\n  const statusCode = 403\n  const message = 'You can\\'t do this!'.\n  const data = { foo: 'bar' }\n  throw new HttpError(statusCode, message, data)\n}\n")),Object(i.b)("p",null,"and then in client it will be thrown as an Error with corresponding ",Object(i.b)("inlineCode",{parentName:"p"},".message")," and ",Object(i.b)("inlineCode",{parentName:"p"},".data")," fields."),Object(i.b)("h3",{id:"action"},"Action"),Object(i.b)("p",null,"Actions are very similar to Queries, so similar that we will only list the differences:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"They can modify state."),Object(i.b)("li",{parentName:"ol"},"There is no special React hook for them (like ",Object(i.b)("inlineCode",{parentName:"li"},"useQuery")," for Queries)."),Object(i.b)("li",{parentName:"ol"},"They are declared in Wasp in same way as Queries, but keyword is ",Object(i.b)("inlineCode",{parentName:"li"},"action"),", not ",Object(i.b)("inlineCode",{parentName:"li"},"query"),".")),Object(i.b)("p",null,"More differences and action/query specific features will come in the future versions of Wasp."))}l.isMDXComponent=!0}}]);